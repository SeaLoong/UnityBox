Shader "SeaLoong/ASS/SecurityBurnShader"
{
    Properties
    {
        _MainTex ("Main Texture", 2D) = "white" {}
        _Color ("Color", Color) = (1,1,1,1)
        _Intensity ("Intensity", Range(0, 10)) = 5
    }

    SubShader
    {
        Tags { "RenderType"="Opaque" "Queue"="Geometry" }
        LOD 100

        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            #pragma multi_compile_fog
            
            #include "UnityCG.cginc"

            struct appdata
            {
                float4 vertex : POSITION;
                float2 uv : TEXCOORD0;
                float3 normal : NORMAL;
            };

            struct v2f
            {
                float2 uv : TEXCOORD0;
                UNITY_FOG_COORDS(1)
                float4 vertex : SV_POSITION;
                float3 worldPos : TEXCOORD2;
                float3 worldNormal : TEXCOORD3;
            };

            sampler2D _MainTex;
            float4 _MainTex_ST;
            float4 _Color;
            float _Intensity;

            // ========== GPU 密集型计算函数 ==========

            // Perlin 噪声（3D，未优化）
            float hash(float3 p)
            {
                p = frac(p * 0.3183099 + 0.1);
                p *= 17.0;
                return frac(p.x * p.y * p.z * (p.x + p.y + p.z));
            }

            float noise(float3 x)
            {
                float3 p = floor(x);
                float3 f = frac(x);
                f = f * f * (3.0 - 2.0 * f);

                return lerp(
                    lerp(
                        lerp(hash(p + float3(0,0,0)), hash(p + float3(1,0,0)), f.x),
                        lerp(hash(p + float3(0,1,0)), hash(p + float3(1,1,0)), f.x),
                        f.y),
                    lerp(
                        lerp(hash(p + float3(0,0,1)), hash(p + float3(1,0,1)), f.x),
                        lerp(hash(p + float3(0,1,1)), hash(p + float3(1,1,1)), f.x),
                        f.y),
                    f.z);
            }

            // Fractal Brownian Motion (8 octaves)
            float fbm(float3 p)
            {
                float value = 0.0;
                float amplitude = 0.5;
                float frequency = 1.0;

                for (int i = 0; i < 8; i++)
                {
                    value += amplitude * noise(p * frequency);
                    frequency *= 2.0;
                    amplitude *= 0.5;
                }

                return value;
            }

            // 复杂光照计算（Phong + Blinn-Phong 混合）
            float3 ComplexLighting(float3 worldPos, float3 normal)
            {
                float3 lightDir = normalize(_WorldSpaceLightPos0.xyz);
                float3 viewDir = normalize(_WorldSpaceCameraPos - worldPos);
                float3 halfDir = normalize(lightDir + viewDir);

                // Diffuse (Lambertian)
                float diffuse = max(0, dot(normal, lightDir));

                // Specular (Phong)
                float3 reflectDir = reflect(-lightDir, normal);
                float specPhong = pow(max(0, dot(viewDir, reflectDir)), 32);

                // Specular (Blinn-Phong)
                float specBlinn = pow(max(0, dot(normal, halfDir)), 64);

                // Rim lighting
                float rim = 1.0 - max(0, dot(viewDir, normal));
                rim = pow(rim, 3) * 0.5;

                return diffuse + specPhong * 0.5 + specBlinn * 0.5 + rim;
            }

            v2f vert (appdata v)
            {
                v2f o;
                o.vertex = UnityObjectToClipPos(v.vertex);
                o.uv = TRANSFORM_TEX(v.uv, _MainTex);
                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
                o.worldNormal = UnityObjectToWorldNormal(v.normal);
                UNITY_TRANSFER_FOG(o,o.vertex);
                return o;
            }

            fixed4 frag (v2f i) : SV_Target
            {
                // ========== 大量纹理采样 ==========
                fixed4 col1 = tex2D(_MainTex, i.uv);
                fixed4 col2 = tex2D(_MainTex, i.uv * 2.0);
                fixed4 col3 = tex2D(_MainTex, i.uv * 3.0);
                fixed4 col4 = tex2D(_MainTex, i.uv * 4.0);
                fixed4 col5 = tex2D(_MainTex, i.uv * 5.0);
                fixed4 col6 = tex2D(_MainTex, i.uv + float2(_Time.y * 0.1, 0));
                fixed4 col7 = tex2D(_MainTex, i.uv + float2(0, _Time.y * 0.1));
                fixed4 col8 = tex2D(_MainTex, i.uv * 0.5 + _Time.y * 0.05);

                // 混合所有采样
                fixed4 col = (col1 + col2 + col3 + col4 + col5 + col6 + col7 + col8) / 8.0;

                // ========== 复杂数学运算 ==========
                
                // FBM 噪声计算
                float3 noisePos = i.worldPos * 2.0 + _Time.y * 0.1;
                float n1 = fbm(noisePos);
                float n2 = fbm(noisePos * 2.0);
                float n3 = fbm(noisePos * 4.0);
                float noiseFinal = (n1 + n2 * 0.5 + n3 * 0.25) / 1.75;

                // 三角函数密集计算
                float wave1 = sin(i.worldPos.x * 10 + _Time.y * 3);
                float wave2 = cos(i.worldPos.y * 10 + _Time.y * 4);
                float wave3 = sin(i.worldPos.z * 10 + _Time.y * 5);
                float wave4 = cos(length(i.worldPos.xy) * 5 + _Time.y * 2);
                float waveFinal = (wave1 + wave2 + wave3 + wave4) / 4.0;

                // 指数运算
                float exp1 = exp(noiseFinal * 0.5);
                float exp2 = exp(waveFinal * 0.3);

                // 对数运算
                float log1 = log(abs(noiseFinal) + 1.0);
                float log2 = log(abs(waveFinal) + 1.0);

                // 幂运算
                float pow1 = pow(abs(noiseFinal), 2.5);
                float pow2 = pow(abs(waveFinal), 3.0);

                // ========== 复杂光照计算 ==========
                float3 lighting = ComplexLighting(i.worldPos, normalize(i.worldNormal));

                // 二次光照计算（模拟多光源）
                float3 lighting2 = ComplexLighting(i.worldPos + float3(1,1,1), normalize(i.worldNormal));
                float3 lighting3 = ComplexLighting(i.worldPos - float3(1,1,1), normalize(i.worldNormal));

                // ========== 最终混合 ==========
                col.rgb *= _Color.rgb;
                col.rgb *= lighting + lighting2 * 0.5 + lighting3 * 0.3;
                col.rgb += noiseFinal * 0.2;
                col.rgb += waveFinal * 0.1;
                col.rgb += (exp1 + exp2 + log1 + log2 + pow1 + pow2) * 0.05;
                col.rgb *= _Intensity;

                // ========== 后处理效果 ==========
                
                // 色彩空间转换（多次）
                float3 hsv = rgb2hsv(col.rgb);
                hsv.x += _Time.y * 0.1;
                col.rgb = hsv2rgb(hsv);

                // 额外的颜色混合
                col.rgb = lerp(col.rgb, 1 - col.rgb, sin(_Time.y) * 0.5 + 0.5);

                // Fog
                UNITY_APPLY_FOG(i.fogCoord, col);

                return col;
            }

            // 辅助函数：RGB to HSV
            float3 rgb2hsv(float3 c)
            {
                float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
                float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
                float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));

                float d = q.x - min(q.w, q.y);
                float e = 1.0e-10;
                return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
            }

            // 辅助函数：HSV to RGB
            float3 hsv2rgb(float3 c)
            {
                float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
            }
            ENDCG
        }
    }

    FallBack "Diffuse"
}
